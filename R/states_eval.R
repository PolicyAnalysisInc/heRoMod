#**************************************************************************
#* 
#* Original work Copyright (C) 2016  Antoine Pierucci
#* Modified work Copyright (C) 2017  Jordan Amdahl
#*
#* This program is free software: you can redistribute it and/or modify
#* it under the terms of the GNU General Public License as published by
#* the Free Software Foundation, either version 3 of the License, or
#* (at your option) any later version.
#*
#* This program is distributed in the hope that it will be useful,
#* but WITHOUT ANY WARRANTY; without even the implied warranty of
#* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#* GNU General Public License for more details.
#*
#* You should have received a copy of the GNU General Public License
#* along with this program.  If not, see <http://www.gnu.org/licenses/>.
#**************************************************************************

#' Evaluate Markov Model States
#' 
#' @param x An `uneval_state_list` object generated by 
#'   [define_state_list()].
#' @param parameters An `eval_parameters` object 
#'   generated by [eval_parameters()].
#' @param expand A tibble identifying which states
#'   should be expanded.
#'   
#' @return An `eval_states` object, a list with one 
#'   data.frame per state containing a column per state 
#'   value and a line per cycle.
#'   
#' @keywords internal
eval_state_list <- function(x, parameters, expand = NULL,
                            disc_method = 'start') {
  
  # Assinging NULLS to avoid CMD Check issues
  .state <- .limit <- state_time <- .value <- NULL
  .full_state <- .name <- .to_name_expanded <- .from_name_expanded <- NULL
  
  # Get number/names of states
  n_states <- length(x)
  state_names <- names(x)
  
  # Fill in expansion table if empty
  if (is.null(expand)) {
    expand <- tibble::tibble(
      .state = state_names,
      .full_state = state_names,
      state_time = 1,
      .expand = F,
      .limit = 1
    )
  }
  
  var_names <- names(x[[1]])
  param_names <- colnames(parameters);

  expanding <- any(expand$.expand)
  
  exp_state_names <- expand$.full_state
  
  f <- function(i) {
    obj <- discount_hack(x[[i]], method = disc_method)
    
    # update calls to dispatch_strategy()
    obj <- dispatch_strategy_hack(obj)
    obj <- by_group_hack(obj)
    
    char_formulas <- as.character(lapply(obj, deparse))
    zero_indices <- char_formulas == '0'
    zero_names <- var_names[zero_indices]
    obj_no_zeros <- obj[!zero_indices]
    params_with_zeros <- parameters
    params_with_zeros[ , zero_names] <- 0
    
    
    if (expanding) {
      # bottleneck!
      parameters %>%
        safe_eval(obj_no_zeros, .vartype = "value") %>%
        mutate(.state = state_names[i]) %>%
        .[c("markov_cycle", "state_time", ".state", var_names)]
    } else {
      
      # bottleneck!
      res <- safe_eval(parameters, obj_no_zeros, .vartype = "value")
      res$.state <- state_names[i]
      res[ ,c("markov_cycle", "state_time", ".state", var_names)]
    }
    
  }
  # Evaluate and Handle expansion
  vars_df <- plyr::ldply(seq_len(n_states), f)
  vars_df <- vars_df %>%
    left_join(expand, by = c(".state" =  ".state", "state_time" = "state_time")) %>%
    filter(state_time <= .limit) %>%
    mutate(
      .full_state = factor(.full_state, levels = unique(exp_state_names))
    ) %>%
    select(!!!syms(c("markov_cycle",".full_state", var_names)))
  split_vec <- vars_df$.full_state
  cols_to_keep <- setdiff(colnames(vars_df), ".full_state")
  vars_df_list <- split(vars_df[ ,cols_to_keep], split_vec)
  
  res <- structure(
    vars_df_list,
    class = c("eval_state_list", class(vars_df_list))
  )
  
  # Evaluate state transition values (if present)
  state_trans_uneval <- attr(x, "transitions")
  if (!is.null(state_trans_uneval)) {
    
    # Get number/names of states
    n_states_trans <- length(state_trans_uneval)
    from_state_names <- lapply(state_trans_uneval, function(y) attr(y, "from"))
    to_state_names <- lapply(state_trans_uneval, function(y) attr(y, "to"))
    
    f_state_val <- function(i) {
      obj <- discount_hack(state_trans_uneval[[i]], method = disc_method)
      from_states <- from_state_names[[i]]
      to_states <- to_state_names[[i]]
      filter_self_trans <- F
      if (any(is.na(from_states)) || any(is.na(to_states))) {
        filter_self_trans <- T
        if (any(is.na(from_states))) from_states <- state_names
        if (any(is.na(to_states))) to_states <- state_names
        
      }
      from_states_expanded <- filter(expand, .state %in% from_states)
      max_st <- max(expand$.limit)
      
      # update calls to dispatch_strategy()
      obj <- dispatch_strategy_hack(obj)
      obj <- by_group_hack(obj)
      
      var_names <- names(obj)
      
      # bottleneck!
      if (expanding) {
        eval_params <- parameters %>%
          mutate(.trans_id = i) %>%
          safe_eval(obj, .vartype = "value") %>%
          .[c("markov_cycle", "state_time", ".trans_id", var_names)]
      } else {
        eval_params <- parameters %>%
          mutate(.trans_id = i) %>%
          safe_eval(obj, .vartype = "value") %>%
          .[c("markov_cycle", "state_time", ".trans_id", var_names)]
      }
      
      # Expand evaluated values to all relevant to/from states
      to_from_df <- expand.grid(
        .from = from_states,
        .to = to_states,
        stringsAsFactors = FALSE
      )
      if (filter_self_trans) {
        to_from_df <- filter(to_from_df, .from != .to)
      }
      tidyr::crossing(to_from_df, eval_params)
    }
    st_var_df <- ldply(seq_len(n_states_trans), f_state_val)
    
    # Evaluate and Handle expansion
    st_var_df <- st_var_df %>%
      left_join(
        transmute(
          expand,
          .state = .state,
          .from_name_expanded = .full_state,
          .limit = .limit,
          state_time = state_time
        ),
        by = c(".from" =  ".state", "state_time" = "state_time")
      ) %>%
      mutate(.to_state_time = 1) %>%
      left_join(
        transmute(
          expand,
          .state = .state,
          .to_name_expanded = .full_state,
          state_time = state_time
        ),
        by = c(".to" =  ".state", ".to_state_time" = "state_time")
      ) %>%
      filter(state_time <= .limit) %>%
      mutate(
        .to_name_expanded = factor(.to_name_expanded, levels = unique(exp_state_names)),
        .from_name_expanded = factor(.from_name_expanded, levels = unique(exp_state_names))
      ) %>%
      select(!!!syms(c("markov_cycle", ".from_name_expanded", ".to_name_expanded", var_names))) %>%
      reshape2::melt(
        id.vars = c(
          "markov_cycle",
          ".from_name_expanded",
          ".to_name_expanded"
        )
      )
    
    attr(res, "transitions") <- st_var_df
  }
  
  res
}

get_state_value_names.eval_state_list <- function(x){
  names(x[[1]])[-1]
}

# Ensure only heRomod version of discount gets used
discount_check <- function(x, env) {
  if (identical(x, quote(discount)) ||
      identical(x, quote(heRomod::discount))) {
    if (identical(x, quote(heRomod::discount)) &&
        (utils::packageVersion("dplyr") <= "0.5" ||
         utils::packageVersion("lazyeval") <= "0.2")) {
      warning("Install the development version of 'lazyeval' and 'dplyr' ",
              'to avoid the error \'could not find function "n"\'.')
    }
    if (identical(environment(eval(x, envir = env)),
                  asNamespace("heRomod"))) {
      TRUE
    } else {
      warning("A version of 'discount()' that is not defined by heRomod was found.")
      FALSE
    }
  } else {
    FALSE
  }
}
